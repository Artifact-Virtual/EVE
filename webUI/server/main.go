package main

import (
	"encoding/json"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"strings"
)

// File defines the structure for a generated file.
type File struct {
	Path     string `json:"path"`
	Content  string `json:"content"`
	Language string `json:"language"`
}

// MessagePart defines the structure for parts of a message.
// The `Content` field uses json.RawMessage to handle different types.
type MessagePart struct {
	Type    string          `json:"type"`
	Content json.RawMessage `json:"content"`
}

// Message defines the structure for a complete message.
type Message struct {
	Sender string        `json:"sender"`
	Parts  []MessagePart `json:"parts"`
}

// spaHandler serves the static single-page application, correctly handling routing.
type spaHandler struct {
	staticPath string
	indexPath  string
}

// ServeHTTP handles all requests by serving static files or the main index.html file.
func (h spaHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	// Get the absolute path to prevent directory traversal
	path, err := filepath.Abs(r.URL.Path)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	// For API calls, let another handler take care of it.
	if strings.HasPrefix(path, "/api") {
		http.NotFound(w, r)
		return
	}

	// Prepend the path with the path to the static directory
	path = filepath.Join(h.staticPath, path)

	// Check if a file exists at the given path
	_, err = os.Stat(path)
	if os.IsNotExist(err) {
		// File does not exist, serve index.html for SPA routing
		http.ServeFile(w, r, filepath.Join(h.staticPath, h.indexPath))
		return
	} else if err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	// Otherwise, serve the static file
	http.FileServer(http.Dir(h.staticPath)).ServeHTTP(w, r)
}

// chatHandler handles requests to the /api/chat endpoint.
func chatHandler(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Only POST method is allowed", http.StatusMethodNotAllowed)
		return
	}

	// For demonstration, we return a hardcoded response with a complex file structure.
	// In a real application, you would parse the request body,
	// call your AI logic, and then construct the response.

	// Marshal the content parts into json.RawMessage
	textContent, _ := json.Marshal("Certainly! I've generated a new standalone Angular component for you. You can browse the files below.")
	filesContent, _ := json.Marshal([]File{
		{
			Path:     "src/components/greeter/greeter.component.ts",
			Content:  "import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-greeter',\n  templateUrl: './greeter.component.html',\n})\nexport class GreeterComponent {\n  greeting = 'Hello from EVE!';\n}",
			Language: "typescript",
		},
		{
			Path:     "src/components/greeter/greeter.component.html",
			Content:  "<div class=\"p-4 bg-purple-200 text-purple-800 rounded-lg\">\n  <h1 class=\"text-2xl font-bold\">{{ greeting }}</h1>\n  <p>This is your new Greeter component.</p>\n</div>",
			Language: "html",
		},
		{
			Path:     "src/components/greeter/greeter.component.css",
			Content:  "/* Add any specific styles for your component here */",
			Language: "css",
		},
		{
			Path:     "README.md",
			Content:  "# Greeter Component\n\nThis component was generated by EVE. It's a simple standalone component to show how file generation works.",
			Language: "markdown",
		},
	})

	response := Message{
		Sender: "assistant",
		Parts: []MessagePart{
			{
				Type:    "text",
				Content: textContent,
			},
			{
				Type:    "files",
				Content: filesContent,
			},
		},
	}

	w.Header().Set("Content-Type", "application/json")
	if err := json.NewEncoder(w).Encode(response); err != nil {
		http.Error(w, "Failed to encode response", http.StatusInternalServerError)
	}
}

func main() {
	// Handle the API endpoint
	http.HandleFunc("/api/chat", chatHandler)

	// Serve the static Angular app.
	// The static files are expected to be in the root directory relative to the server executable.
	spa := spaHandler{staticPath: ".", indexPath: "index.html"}
	http.Handle("/", spa)

	port := "8080"
	log.Printf("Starting server on http://localhost:%s\n", port)
	if err := http.ListenAndServe(":"+port, nil); err != nil {
		log.Fatal("ListenAndServe: ", err)
	}
}
